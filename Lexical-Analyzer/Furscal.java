/* Furscal.java */
/* Generated By:JavaCC: Do not edit this line. Furscal.java */
/** Simple brace matcher. */
public class Furscal implements FurscalConstants {
  /** Main entry point. */
  public static void main(String args[]) throws ParseException, TokenMgrError
  {
    Furscal parser = new Furscal(System.in);
    parser.Input();
  }

/** Parser/Syntax analyzer specification! */
/** Root production. */
/** This only checks that there are no errors. 
 * It outputs nothing, except errors if any.
*/
  static final public void Input() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMENT:
      case TYPE:
      case INTDEF:
      case DECIMALDEF:
      case BOOLDEF:
      case CHARDEF:
      case STRINGDEF:
      case DATEDEF:
      case TIMEDEF:
      case DATETIMEDEF:
      case ARR:
      case MATRIX:
      case ARRAYSETDEF:
      case CONSTANT:
      case NULL:
      case GLOBAL:
      case ARITHMETICOPERATOR:
      case POWER:
      case POSTFIXINC:
      case POSTFIXDEC:
      case MODULUS:
      case ASSIGN:
      case SHIFTLEFT:
      case SHIFTRIGHT:
      case RELATIONALOPERATOR:
      case LOGICALOPERATOR:
      case FUNCTIONDECLARE:
      case RETURN:
      case QUESTION:
      case DEFAULT_:
      case LOOP:
      case LOOPCOUNTER:
      case LOOPUNTIL:
      case LOOPTESTBEFORE:
      case LOOPTESTAFTER:
      case SHOW:
      case CLEAR:
      case EXIT:
      case TYPEOF:
      case HALT:
      case PROCEED:
      case CLASSDECLARE:
      case OBJECTDECLARE:
      case SELF:
      case PASSALL:
      case CHECK:
      case ONERROR:
      case AFTERALL:
      case REQUIRE:
      case FROM:
      case LINE_END:
      case SEPARATOR:
      case PARENTHESIS_LEFT:
      case PARENTHESIS_RIGHT:
      case SQUARE_LEFT:
      case SQUARE_RIGHT:
      case BRACKET_LEFT:
      case BRACKET_RIGHT:
      case PROCEDURE:
      case SET:
      case SET_OPERATIONS:
      case SET_COMPARISONS:
      case MATH_CONSTANTS:
      case TRIG_FUNCTIONS:
      case ASSIGN_OPERATORS:
      case ARITHMETIC_FUNCTIONS:
      case ID:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMENT:{
        jj_consume_token(COMMENT);
        break;
        }
      case TYPE:{
        jj_consume_token(TYPE);
        break;
        }
      case INTDEF:{
        jj_consume_token(INTDEF);
        break;
        }
      case DECIMALDEF:{
        jj_consume_token(DECIMALDEF);
        break;
        }
      case BOOLDEF:{
        jj_consume_token(BOOLDEF);
        break;
        }
      case CHARDEF:{
        jj_consume_token(CHARDEF);
        break;
        }
      case STRINGDEF:{
        jj_consume_token(STRINGDEF);
        break;
        }
      case DATEDEF:{
        jj_consume_token(DATEDEF);
        break;
        }
      case TIMEDEF:{
        jj_consume_token(TIMEDEF);
        break;
        }
      case DATETIMEDEF:{
        jj_consume_token(DATETIMEDEF);
        break;
        }
      case ARR:{
        jj_consume_token(ARR);
        break;
        }
      case MATRIX:{
        jj_consume_token(MATRIX);
        break;
        }
      case ARRAYSETDEF:{
        jj_consume_token(ARRAYSETDEF);
        break;
        }
      case CONSTANT:{
        jj_consume_token(CONSTANT);
        break;
        }
      case NULL:{
        jj_consume_token(NULL);
        break;
        }
      case GLOBAL:{
        jj_consume_token(GLOBAL);
        break;
        }
      case ARITHMETICOPERATOR:{
        jj_consume_token(ARITHMETICOPERATOR);
        break;
        }
      case POWER:{
        jj_consume_token(POWER);
        break;
        }
      case POSTFIXINC:{
        jj_consume_token(POSTFIXINC);
        break;
        }
      case POSTFIXDEC:{
        jj_consume_token(POSTFIXDEC);
        break;
        }
      case MODULUS:{
        jj_consume_token(MODULUS);
        break;
        }
      case ASSIGN:{
        jj_consume_token(ASSIGN);
        break;
        }
      case SHIFTLEFT:{
        jj_consume_token(SHIFTLEFT);
        break;
        }
      case SHIFTRIGHT:{
        jj_consume_token(SHIFTRIGHT);
        break;
        }
      case RELATIONALOPERATOR:{
        jj_consume_token(RELATIONALOPERATOR);
        break;
        }
      case LOGICALOPERATOR:{
        jj_consume_token(LOGICALOPERATOR);
        break;
        }
      case FUNCTIONDECLARE:{
        jj_consume_token(FUNCTIONDECLARE);
        break;
        }
      case RETURN:{
        jj_consume_token(RETURN);
        break;
        }
      case QUESTION:{
        jj_consume_token(QUESTION);
        break;
        }
      case DEFAULT_:{
        jj_consume_token(DEFAULT_);
        break;
        }
      case LOOP:{
        jj_consume_token(LOOP);
        break;
        }
      case LOOPCOUNTER:{
        jj_consume_token(LOOPCOUNTER);
        break;
        }
      case LOOPUNTIL:{
        jj_consume_token(LOOPUNTIL);
        break;
        }
      case LOOPTESTAFTER:{
        jj_consume_token(LOOPTESTAFTER);
        break;
        }
      case LOOPTESTBEFORE:{
        jj_consume_token(LOOPTESTBEFORE);
        break;
        }
      case SHOW:{
        jj_consume_token(SHOW);
        break;
        }
      case CLEAR:{
        jj_consume_token(CLEAR);
        break;
        }
      case EXIT:{
        jj_consume_token(EXIT);
        break;
        }
      case TYPEOF:{
        jj_consume_token(TYPEOF);
        break;
        }
      case HALT:{
        jj_consume_token(HALT);
        break;
        }
      case PROCEED:{
        jj_consume_token(PROCEED);
        break;
        }
      case CLASSDECLARE:{
        jj_consume_token(CLASSDECLARE);
        break;
        }
      case OBJECTDECLARE:{
        jj_consume_token(OBJECTDECLARE);
        break;
        }
      case SELF:{
        jj_consume_token(SELF);
        break;
        }
      case PASSALL:{
        jj_consume_token(PASSALL);
        break;
        }
      case CHECK:{
        jj_consume_token(CHECK);
        break;
        }
      case ONERROR:{
        jj_consume_token(ONERROR);
        break;
        }
      case AFTERALL:{
        jj_consume_token(AFTERALL);
        break;
        }
      case REQUIRE:{
        jj_consume_token(REQUIRE);
        break;
        }
      case FROM:{
        jj_consume_token(FROM);
        break;
        }
      case LINE_END:{
        jj_consume_token(LINE_END);
        break;
        }
      case SEPARATOR:{
        jj_consume_token(SEPARATOR);
        break;
        }
      case PARENTHESIS_LEFT:{
        jj_consume_token(PARENTHESIS_LEFT);
        break;
        }
      case PARENTHESIS_RIGHT:{
        jj_consume_token(PARENTHESIS_RIGHT);
        break;
        }
      case SQUARE_LEFT:{
        jj_consume_token(SQUARE_LEFT);
        break;
        }
      case SQUARE_RIGHT:{
        jj_consume_token(SQUARE_RIGHT);
        break;
        }
      case BRACKET_LEFT:{
        jj_consume_token(BRACKET_LEFT);
        break;
        }
      case BRACKET_RIGHT:{
        jj_consume_token(BRACKET_RIGHT);
        break;
        }
      case PROCEDURE:{
        jj_consume_token(PROCEDURE);
        break;
        }
      case SET:{
        jj_consume_token(SET);
        break;
        }
      case SET_OPERATIONS:{
        jj_consume_token(SET_OPERATIONS);
        break;
        }
      case SET_COMPARISONS:{
        jj_consume_token(SET_COMPARISONS);
        break;
        }
      case MATH_CONSTANTS:{
        jj_consume_token(MATH_CONSTANTS);
        break;
        }
      case TRIG_FUNCTIONS:{
        jj_consume_token(TRIG_FUNCTIONS);
        break;
        }
      case ASSIGN_OPERATORS:{
        jj_consume_token(ASSIGN_OPERATORS);
        break;
        }
      case ARITHMETIC_FUNCTIONS:{
        jj_consume_token(ARITHMETIC_FUNCTIONS);
        break;
        }
      case ID:{
        jj_consume_token(ID);
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
System.out.println("\nNo invalid strings found.");
}

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public FurscalTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0xffffffc0,0xffffffc0,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0xffffffff,0xffffffff,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x4ff,0x4ff,};
	}

  /** Constructor with InputStream. */
  public Furscal(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Furscal(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new FurscalTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Furscal(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new FurscalTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new FurscalTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Furscal(FurscalTokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(FurscalTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[75];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 2; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 75; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
